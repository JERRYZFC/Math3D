<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
// MIT License - Copyright (C) Ara 3D, Inc.
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

<# 
var nonVectorTypes = new[] { "int", "long", "float", "double" };
var vectorTypes = new[] { "Vector2", "Vector3", "Vector4" };
var types = nonVectorTypes.Concat(vectorTypes);
var intTypes = new[] { "int", "long" };
var araBinaryOps = new[] { "Add", "Sub", "Mul", "Div" };
var araCompOps = new[] { "Gt", "Lt", "GtEq", "LtEq", "Eq", "NEq" };
var sysUnaryOps = new[] { "Abs", "Acos", "Asin", "Atan", "Cos", "Cosh", "Exp", "Log", "Log10", "Sin", "Sinh", "Sqrt", "Tan", "Tanh" };
var araUnaryOps = new[] { "Sqr", "Inverse", "Ceiling", "Floor", "Round", "Truncate" };
var allUnaryOps = sysUnaryOps.Concat(araUnaryOps);
#>

using System.Numerics;

namespace Ara3D 
{
	public static class MathOps
	{
		public static double Sqr(this double self) { return self * self; }
		public static double Ceiling(this double self) { return System.Math.Ceiling(self); }
		public static double Floor(this double self) { return System.Math.Floor(self); }
		public static double Round(this double self) { return System.Math.Round(self); }
		public static double Truncate(this double self) { return System.Math.Ceiling(self); }
		public static double Inverse(this double self) { return 1.0 / self; }
		public static float Sqr(this float self) { return self * self; }
		public static float Ceiling(this float self) { return (float)System.Math.Ceiling(self); }
		public static float Floor(this float self) { return (float)System.Math.Floor(self); }
		public static float Round(this float self) { return (float)System.Math.Round(self); }
		public static float Truncate(this float self) { return (float)System.Math.Ceiling(self); }
		public static float Inverse(this float self) { return 1.0f / self; }
	
<# 
foreach (var t in types) { 
#>
        public static <#= t #> Add (this <#= t #> v1, <#= t #> v2) { return v1 + v2; }
        public static <#= t #> Sub (this <#= t #> v1, <#= t #> v2) { return v1 - v2; }
        public static <#= t #> Mul (this <#= t #> v1, <#= t #> v2) { return v1 * v2; }
        public static <#= t #> Div (this <#= t #> v1, <#= t #> v2) { return v1 / v2; }
		public static <#= t #> Negate (this <#= t #> v) { return -v; }
        //public static <#= t #> Mod (this <#= t #> v1, <#= t #> v2) { return v1 % v2; }
<#
} 
foreach (var t in nonVectorTypes) { 
#>

        public static <#= t #> Min (this <#= t #> v1, <#= t #> v2) { return System.Math.Min(v1, v2); }
        public static <#= t #> Max (this <#= t #> v1, <#= t #> v2) { return System.Math.Max(v1, v2); }
<#
}
foreach (var op in sysUnaryOps) {
#>
		public static double <#= op #>(this double self) { return System.Math.<#= op #>(self); }
		public static float <#= op #>(this float self) { return (float)System.Math.<#= op #>(self); }
<#
}
foreach (var op in allUnaryOps) {
#>

		public static Vector2 <#= op #>(this Vector2 self) { return self.Select(<#= op #>); }
		public static Vector3 <#= op #>(this Vector3 self) { return self.Select(<#= op #>); }
		public static Vector4 <#= op #>(this Vector4 self) { return self.Select(<#= op #>); }
<# 
} 
#>
		
	} 
} 
