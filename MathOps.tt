<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
// MIT License - Copyright (C) Ara 3D, Inc.
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

<# 
var nonVectorTypes = new[] { "int", "float" };
var types = new[] { "int", "float", "Vector3", "Vector4" };
var comparableTypes = new[] { "int", "float" };
var intTypes = new[] { "int", "long" };
var araBinaryOps = new[] { "Add", "Sub", "Mul", "Div" };
var araUnaryOps = new[] { "Negate" };
var araCompOps = new[] { "Gt", "Lt", "GtEq", "LtEq", "Eq", "NEq" };
var sysUnaryOps = new[] { "Abs", "Acos", "Asin", "Atan", "Cos", "Cosh", "Exp", "Log", "Log10", "Sin", "Sinh", "Sqrt", "Tan", "Tanh" };
var sysAmbiguousUnaryOps = new[] { "Ceiling", "Floor", "Round", "Truncate" };
var sysBinaryOps = new[] { "Atan2", "Log", "Pow" };
#>

using System;
using System.Numerics;
using System.Collections.Generic;
using System.Linq;

namespace Ara3D 
{
	public static class MathOps {

<# 
foreach (var t in types) { 
#>
        public static <#= t #> Add (this <#= t #> v1, <#= t #> v2) { return v1 + v2; }
        public static <#= t #> Sub (this <#= t #> v1, <#= t #> v2) { return v1 - v2; }
        public static <#= t #> Mul (this <#= t #> v1, <#= t #> v2) { return v1 * v2; }
        public static <#= t #> Div (this <#= t #> v1, <#= t #> v2) { return v1 / v2; }
        //public static <#= t #> Mod (this <#= t #> v1, <#= t #> v2) { return v1 % v2; }
		public static <#= t #> Neg (this <#= t #> v) { return -v; }
<# } 
foreach (var t in nonVectorTypes) { 
#>

        public static <#= t #> Min (this <#= t #> v1, <#= t #> v2) { return System.Math.Min(v1, v2); }
        public static <#= t #> Max (this <#= t #> v1, <#= t #> v2) { return System.Math.Max(v1, v2); }

		<#
		foreach (var op2 in sysBinaryOps) {
		#>
        public static double <#= op2 #> (this <#= t #> v1, <#= t #> v2) { return System.Math.<#= op2 #>(v1, v2); }
		<#
		}
		foreach (var op1 in sysUnaryOps) {
		#>
        public static double <#= op1 #> (this <#= t #> v) { return System.Math.<#= op1 #>(v); }
		<#
		}		
		}
foreach (var t in comparableTypes) { 
#>
        public static bool Gt (this <#= t #> v1, <#= t #> v2) { return v1 > v2; }
        public static bool Lt (this <#= t #> v1, <#= t #> v2) { return v1 < v2; }
        public static bool GtEq (this <#= t #> v1, <#= t #> v2) { return v1 >= v2; }
        public static bool LtEq (this <#= t #> v1, <#= t #> v2) { return v1 <= v2; }
        public static bool Eq (this <#= t #> v1, <#= t #> v2) { return v1 == v2; }
        public static bool NEq (this <#= t #> v1, <#= t #> v2) { return v1 != v2; }
<# } #>

		public static bool And (this bool a, bool b) { return a && b; }
		public static bool Or (this bool a, bool b) { return a || b; }
		public static bool NAnd (this bool a, bool b) { return !(a && b); }
		public static bool XOr (this bool a, bool b) { return a || b && !(a && b); }
		public static bool NOr (this bool a, bool b) { return !(a || b); }
		public static bool Not (this bool a) { return !a; }

		// TODO: parameterize over all of the integer types
<# 
foreach (var t in intTypes) { 
#>
		public static <#= t #> And (this <#= t #> a, <#= t #> b) { return a & b; }
		public static <#= t #> Or (this <#= t #> a, <#= t #> b) { return a | b; }
		public static <#= t #> NAnd (this <#= t #> a, <#= t #> b) { return ~(a & b); }
		public static <#= t #> XOr (this <#= t #> a, <#= t #> b) { return a | b & ~(a & b); }
		public static <#= t #> NOr (this <#= t #> a, <#= t #> b) { return ~(a | b); }
		public static <#= t #> Not (this <#= t #> a) { return ~a; }
<# } #>

<# 
foreach (var t2 in types) 
{
	foreach (var op in araBinaryOps) 
	{		
		var n = op.LastIndexOf(".");
		var baseOpName = n >= 0 ? op.Substring(n + 1) : op;
		foreach (var ts in new[] { "IArray<" + t2 + ">", "IEnumerable<" + t2 + ">" }) {
#>
		public static <#= ts #> <#= baseOpName #>( this <#= ts #> v1s, <#= ts #> v2s) { return v1s.Zip(v2s, <#= op #>); }
		public static <#= ts #> <#= baseOpName #>( this <#= ts #> v1s, <#= t2 #> v2) { return v1s.Select(v1 => <#= op #>(v1, v2)); }
<#		} } }#>
    }
}